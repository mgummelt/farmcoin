#include <climits>
#include <cstring>
#include <iostream>
#include <set>

#include "block.h"
#include "key.h"
#include "txn.h"
#include "utils.h"

using namespace std;

BlockHeader::BlockHeader() {}

BlockHeader::BlockHeader(vector<Txn>& txns) {
  rand = lrand();
  numTxns = txns.size();
  hashBlock(txns);
}

// Hash a block and store the result in this->hash.  The hash of a
// block with N transactions has size sizeof(BlockHeader) + N *
// sizeof(Txn).  Using the size of the class introduces padding
// inconsistencies in general, but is safe assuming the network runs
// with the same compiler and architecture (gcc, myth).
void BlockHeader::hashBlock(vector<Txn>& txns) {
  // TODO: Step 4
}

// Read this BlockHeader and all associated Txns from a BLOCK request.
void BlockHeader::readBlock(istream& ss, vector<Txn>& txns) {
  ss.read((char*)this, sizeof(BlockHeader));

  for(int i = 0; i < numTxns; i++) {
    Txn t;
    ss.read((char*)&t, sizeof(Txn));
    txns.push_back(t);
  }
}

// Rarity check.  On a global network, 1/5 of computed hashes are
// considered rare enough.  We slow this down on the global network to
// 1/60, in order to limit network activity.
static const int kGlobalRarity = 60;
static const int kLocalRarity = 5;
bool BlockHeader::isRare() {
  return hash[0] < UCHAR_MAX / (global ? kGlobalRarity : kLocalRarity);
}

// Called by master to verify a block.  Returns 0 if the block is
// valid.  Returns one of the following error codes if it's invalid:
//
//   1: Farmer computed an incorrect hash.  The hash provided in the
//      BlockHeader does not match the hash computed by master.
//   2: Hash is not rare enough.
//   3: One of the transactoins in the block is not valid.
//   4: The coin ID of the coinbase generated by the farmer already
//      exists.
//   5: The block contains multiple transactions for the same coin ID.
//   6: The block contains no transacitons.
int BlockHeader::verifyBlock(vector<Txn>& txns,
                             vector<Txn>& verifiedTxns,
                             BlockHeader& cpy) {
  if (txns.size() == 0) {
    return 6;
  }

  if (memcmp(hash, cpy.hash, SHA_DIGEST_LENGTH) != 0) {
    // hash is invalid
    return 1;
  } else if (!isRare()) {
    // hash does not satisfy the necessary constraints
    return 2;
  } else {

    set<coin_id_t> seenCoinIDs;
    for (int i = 1; i < txns.size(); i++) {
      Txn& t = txns[i];
      if (t.verifySig(verifiedTxns) != 1) {
        // One of the Txns is invalid
        return 3;
      } else if(seenCoinIDs.find(t.coinID) != seenCoinIDs.end()) {
        // multiple transactions for the same coin
        return 5;
      }
      seenCoinIDs.insert(t.coinID);
    }

    Txn& coinbase = txns[0];
    for (Txn& t : verifiedTxns) {
      if (t.coinID == coinbase.coinID) {
        // The coinID of the coinbase matches an existing coin.
        return 4;
      }
    }

    // valid block
    return 0;
  }
}
